<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TKG Call Log</title>
</head>
<body>
  <h1>TKG Call Log (All Calls)</h1>

  <button onclick="loadCalls()">Refresh</button>

  <pre id="output">Loading...</pre>

  <script>
  // ---- CONFIG ----
  const MAX_PAGES = 20; // increase if you want longer history and have heavy volume

  // ---- Helpers ----
  function pad2(n) { return String(n).padStart(2, "0"); }

  function formatLocal(dt) {
    // dt may be "Wed, 07 Jan 2026 06:41:11 +0000"
    const d = new Date(dt);
    if (Number.isNaN(d.getTime())) return dt || "";
    // dd/mm/yyyy hh:mm:ss in local time
    return `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}/${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
  }

  function outcomeFromCall(c) {
    // Twilio: status can be "completed", "no-answer", "busy", "failed", "canceled", etc.
    // duration is "0" for missed/no-answer in most cases.
    const status = (c.status || "").toLowerCase();
    const duration = Number(c.duration || 0);

    if (status === "completed" && duration > 0) return "Answered";
    if (status === "completed" && duration === 0) return "Missed";
    if (status === "no-answer") return "Missed";
    if (status === "busy") return "Busy";
    if (status === "failed") return "Failed";
    if (status === "canceled") return "Canceled";
    return status ? status : "Unknown";
  }

  function getSelectedHours() {
    // Assumes your dropdown has id="range"
    const el = document.getElementById("range");
    if (!el) return 1;

    const v = el.value;

    // Support common patterns:
    // - numeric hours: "1", "3", "24", "168"
    // - labels: "Last 60 minutes", "Last 3 hours", "Today", "All time"
    if (/^\d+$/.test(v)) return Number(v);

    const lower = v.toLowerCase();
    if (lower.includes("60")) return 1;
    if (lower.includes("3")) return 3;
    if (lower.includes("today")) return 24;
    if (lower.includes("all")) return 24 * 365; // 1 year as "all time" cap (adjust if needed)

    return 1;
  }

  function setInfo(text) {
    const info = document.getElementById("info");
    if (info) info.textContent = text;
  }

  function setWarn(text) {
    const warn = document.getElementById("warn");
    if (warn) {
      warn.textContent = text || "";
      warn.style.display = text ? "block" : "none";
    }
  }

  function clearTable() {
    const table = document.querySelector("table");
    if (!table) return;

    // Remove all rows except header
    const rows = Array.from(table.querySelectorAll("tr"));
    rows.slice(1).forEach(r => r.remove());
  }

  function addRowToTable({ time, from, outcome, duration }) {
    const table = document.querySelector("table");
    if (!table) return;

    const tr = document.createElement("tr");

    const tdTime = document.createElement("td");
    tdTime.textContent = time;

    const tdFrom = document.createElement("td");
    tdFrom.textContent = from || "";

    const tdOutcome = document.createElement("td");
    tdOutcome.textContent = outcome || "";

    const tdDuration = document.createElement("td");
    tdDuration.textContent = String(duration ?? "");

    tr.appendChild(tdTime);
    tr.appendChild(tdFrom);
    tr.appendChild(tdOutcome);
    tr.appendChild(tdDuration);

    table.appendChild(tr);
  }

  async function loadAllCalls() {
    try {
      setWarn("");
      setInfo("Loading…");
      clearTable();

      const hours = getSelectedHours();
      const url = `/.netlify/functions/calls?hours=${encodeURIComponent(hours)}&maxPages=${encodeURIComponent(MAX_PAGES)}`;

      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) {
        const t = await r.text();
        throw new Error(`Function error ${r.status}: ${t}`);
      }

      const data = await r.json();
      const calls = Array.isArray(data) ? data : (data.calls || []);

      // Sort newest first by start_time/date_created
      calls.sort((a, b) => {
        const ta = Date.parse(a.start_time || a.date_created || "") || 0;
        const tb = Date.parse(b.start_time || b.date_created || "") || 0;
        return tb - ta;
      });

      // Render each call (NO DEDUPE)
      for (const c of calls) {
        addRowToTable({
          time: formatLocal(c.start_time || c.date_created),
          from: c.from,
          outcome: outcomeFromCall(c),
          duration: c.duration ?? ""
        });
      }

      const now = new Date();
      const lastRefresh = formatLocal(now.toString());

      const countText = (Array.isArray(data) ? calls.length : (data.count ?? calls.length));
      setInfo(`Showing ${calls.length} calls • last refresh ${formatLocal(now)}`);

      // Optional: show pagination stats if provided
      if (!Array.isArray(data) && (data.pagesFetched || data.hours)) {
        setWarn(`Pulled ${countText} calls over ${data.pagesFetched || "?"} page(s) for last ${data.hours || hours} hour(s).`);
      }

    } catch (err) {
      setWarn(String(err.message || err));
      setInfo("No data loaded.");
    }
  }

  // Hook up buttons (assumes your buttons call these ids)
  document.addEventListener("DOMContentLoaded", () => {
    // If your HTML uses inline onclick attributes, this still works, but we also attach handlers.
    const refreshBtn = document.querySelector("button#refresh") || Array.from(document.querySelectorAll("button")).find(b => /refresh/i.test(b.textContent));
    if (refreshBtn) refreshBtn.addEventListener("click", loadAllCalls);

    const range = document.getElementById("range");
    if (range) range.addEventListener("change", loadAllCalls);

    // initial load
    loadAllCalls();
  });

  // If your HTML uses inline onclick="refresh()" etc, expose a global:
  window.refresh = loadAllCalls;
</script>

</body>
</html>
